name: CI/CD Pipeline for Web Calculator

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

env:
  # 明确指定镜像推送到您的组织
  REGISTRY: ghcr.io
  IMAGE_NAME: wkk08/web-calculator-ci-cd

jobs:
  # 第一阶段：单元测试
  unit-test:
    name: Unit Tests
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.12'
          cache: 'pip'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Run unit tests
        run: |
          python -m pytest tests/unit/ -v --cov=app --cov-report=xml

      - name: Upload coverage report
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: coverage-report
          path: coverage.xml

  # 第二阶段：功能测试
  functional-test:
    name: Functional Tests
    runs-on: ubuntu-latest
    needs: unit-test
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.12'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Run functional tests
        run: |
          # 启动Flask应用
          python app.py &
          APP_PID=$!
          
          # 等待应用启动
          sleep 5
          
          # 运行测试
          echo "测试健康检查..."
          curl -f "http://localhost:5000/health" || (echo "健康检查失败"; exit 1)
          
          echo "测试加法..."
          curl -f "http://localhost:5000/add/2&3" || (echo "加法测试失败"; exit 1)
          
          echo "测试乘法..."
          curl -f "http://localhost:5000/multiply/4&5" || (echo "乘法测试失败"; exit 1)
          
          echo "测试无效输入..."
          STATUS_CODE=$(curl -s -o /dev/null -w "%{http_code}" "http://localhost:5000/add/abc&xyz")
          if [ "$STATUS_CODE" -ne 400 ]; then
            echo "无效输入测试失败，期望400，得到$STATUS_CODE"
            exit 1
          fi
          
          echo "所有功能测试通过！"
          
          # 停止应用
          kill $APP_PID 2>/dev/null || true

  # 第三阶段：构建与推送 (使用安全PAT，明确指向wkk08组织)
  build-and-push:
    name: Build and Push Docker Image
    runs-on: ubuntu-latest
    needs: [unit-test, functional-test]
    # 只在推送到主分支时运行
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    
    permissions:
      contents: read
      packages: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      # 核心：使用个人访问令牌(PAT)登录，而非GITHUB_TOKEN，以避免组织包权限问题
      - name: Log in to GitHub Container Registry with PAT
        run: |
          echo "${{ secrets.GHCR_PAT }}" | docker login ${{ env.REGISTRY }} -u wkk08 --password-stdin

      - name: Build Docker image locally
        id: build
        run: |
          # 构建镜像，使用两种标签
          docker build -t web-calculator:${{ github.sha }} -t web-calculator:latest .
          echo "✅ 本地镜像构建成功"
          docker images | grep web-calculator

      - name: Tag and Push to GHCR
        run: |
          # 标记镜像（明确推送到wkk08组织下）
          docker tag web-calculator:${{ github.sha }} ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}
          docker tag web-calculator:${{ github.sha }} ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest
          
          echo "开始推送镜像到 ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }} ..."
          
          # 推送镜像
          docker push ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}
          docker push ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest
          
          echo "✅ 镜像推送成功！"
          
          # 记录用于部署的镜像名
          echo "DEPLOY_IMAGE=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}" >> $GITHUB_ENV

      - name: Create deployment info file
        run: |
          echo "构建时间: $(date -u '+%Y-%m-%d %H:%M:%S UTC')" > build-info.txt
          echo "提交哈希: ${{ github.sha }}" >> build-info.txt
          echo "完整镜像名: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}" >> build-info.txt

      - name: Upload build info
        uses: actions/upload-artifact@v4
        with:
          name: build-info
          path: build-info.txt
          retention-days: 30

  # 第四阶段：蓝绿部署 (包含稳健的SSH连接和已验证的部署命令)
  deploy:
    name: Blue-Green Deployment
    needs: build-and-push
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # 稳健的SSH设置，使用已验证的密钥和连接参数
      - name: Setup SSH and Test Connection
        run: |
          # 1. 创建 .ssh 目录并设置严格权限 (SSH强制要求)
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          
          # 2. 将私钥从GitHub Secrets写入文件
          echo "${{ secrets.DEPLOY_SSH_PRIVATE_KEY }}" > ~/.ssh/deploy_key
          
          # 3. 绝对关键的权限设置！SSH会拒绝过于开放的私钥文件。
          chmod 600 ~/.ssh/deploy_key
          
          # 4. 将服务器主机指纹加入已知主机列表，避免首次连接交互
          ssh-keyscan -H ${{ secrets.DEPLOY_SERVER_IP }} >> ~/.ssh/known_hosts 2>/dev/null
          
          # 5. 执行连接测试（使用与本地测试相同的逻辑）
          echo "正在执行SSH连接测试..."
          ssh -i ~/.ssh/deploy_key \
              -o BatchMode=yes \
              -o ConnectTimeout=10 \
              -o StrictHostKeyChecking=no \
              ${{ secrets.DEPLOY_USER }}@${{ secrets.DEPLOY_SERVER_IP }} \
              "echo '✅ 来自GitHub Actions Runner的SSH测试成功！'; hostname"
          
          echo "SSH连接测试阶段完成。"

      - name: Copy deployment files to server
        run: |
          # 同步部署文件到服务器（使用已验证的配置）
          rsync -avz --delete \
            --exclude '.git' \
            --exclude '.github' \
            deploy/ \
            ${{ secrets.DEPLOY_USER }}@${{ secrets.DEPLOY_SERVER_IP }}:${{ secrets.DEPLOY_DIR }}/

      - name: Execute Deployment on Server
        run: |
          # SSH到服务器执行部署
          # 此步骤假设您的 deploy/ 目录下已包含正确的：
          # 1. docker-compose.yml (使用 ${BLUE_TAG} 和 ${GREEN_TAG} 变量)
          # 2. nginx/conf.d/default.conf (正确的upstream配置)
          # 3. scripts/ 部署脚本
          ssh -i ~/.ssh/deploy_key \
              -o StrictHostKeyChecking=no \
              ${{ secrets.DEPLOY_USER }}@${{ secrets.DEPLOY_SERVER_IP }} "
            cd ${{ secrets.DEPLOY_DIR }}
            
            # 设置本次部署的镜像标签（由CI流程传入）
            export DEPLOY_IMAGE='${{ env.DEPLOY_IMAGE }}'
            
            # 获取当前活跃颜色，决定本次部署颜色
            if [ -f current_color ]; then
              CURRENT_COLOR=\$(cat current_color)
            else
              CURRENT_COLOR='blue'
            fi
            
            if [ \"\$CURRENT_COLOR\" = 'blue' ]; then
              NEW_COLOR='green'
            else
              NEW_COLOR='blue'
            fi
            
            echo '========================================='
            echo '开始蓝绿部署'
            echo '当前颜色: '\$CURRENT_COLOR
            echo '新颜色: '\$NEW_COLOR
            echo '镜像标签: '\$DEPLOY_IMAGE
            echo '========================================='
            
            # 更新对应颜色的环境变量
            if [ \"\$NEW_COLOR\" = 'blue' ]; then
              sed -i \"s|BLUE_TAG=.*|BLUE_TAG=\$DEPLOY_IMAGE|\" .env
            else
              sed -i \"s|GREEN_TAG=.*|GREEN_TAG=\$DEPLOY_IMAGE|\" .env
            fi
            
            # 使用 podman-compose 拉取新镜像并启动新颜色容器
            podman-compose pull
            podman-compose up -d
            
            # 等待新容器健康检查
            echo '等待新容器健康检查...'
            sleep 30
            
            # 验证新容器健康状态
            if podman-compose ps | grep \"app_\$NEW_COLOR\" | grep -q '(healthy)'; then
              echo '✅ 新容器健康检查通过'
              
              # 切换Nginx流量 (假设您有 switch_traffic 脚本)
              if [ -f ./scripts/switch_traffic ]; then
                ./scripts/switch_traffic \"\$NEW_COLOR\"
              else
                # 如果没有脚本，手动更新nginx配置示例（需根据您的配置调整）
                echo '手动切换流量逻辑（示例）'
              fi
              
              # 更新当前颜色记录
              echo \"\$NEW_COLOR\" > current_color
              echo '✅ 蓝绿部署完成！当前活跃版本: '\$NEW_COLOR
            else
              echo '❌ 新容器健康检查失败，执行回滚'
              # 回滚到旧版本
              if [ -f ./scripts/rollback ]; then
                ./scripts/rollback
              fi
              exit 1
            fi
          "

      - name: Verify Deployment
        run: |
          # 验证部署是否成功
          echo "等待远程服务响应..."
          MAX_RETRIES=15
          RETRY_COUNT=0
          
          while [ \$RETRY_COUNT -lt \$MAX_RETRIES ]; do
            HTTP_CODE=\$(curl -s -o /dev/null -w "%{http_code}" http://${{ secrets.DEPLOY_SERVER_IP }}/health || echo "000")
            if [ \"\$HTTP_CODE\" = "200" ]; then
              echo "✅ 部署验证成功！服务已上线并返回 200 OK。"
              exit 0
            else
              RETRY_COUNT=\$((RETRY_COUNT+1))
              echo "尝试 \$RETRY_COUNT/\$MAX_RETRIES: 服务未就绪 (HTTP Code: \$HTTP_CODE)，等待5秒..."
              sleep 5
            fi
          done
          
          echo "❌ 部署验证失败：服务在多次尝试后未返回健康状态。"
          exit 1

      - name: Deployment Summary
        if: always()
        run: |
          if [ \"\${{ job.status }}\" = 'success' ]; then
            echo '🎉 CI/CD 流水线执行成功！'
            echo '应用已通过蓝绿策略部署到生产环境。'
            echo '访问地址: http://${{ secrets.DEPLOY_SERVER_IP }}'
            echo '健康检查: http://${{ secrets.DEPLOY_SERVER_IP }}/health'
          else
            echo '❌ CI/CD 流水线执行失败。'
            echo '请检查上述日志，特别是部署阶段的错误信息。'
          fi